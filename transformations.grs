rule seyProblem {
	pattern { e : X -[cc]-> Y; Y [lemma=sey] }
	commands { del_edge e  ; add_edge  X -[discourse]-> Y }
}

rule allDet {
	pattern { e : X -[mod]-> Y ; Y [form="all"]}
	commands { del_edge e; add_edge X -[det]-> Y }
}

rule allOf {
	pattern { e : X -[mod]-> Y ; X [form="all"]; Y [form="of"]}
	commands { del_edge e; add_edge X -[udep]-> Y }
}

rule baseOn {
	pattern { e : X -[unk@fixed]-> Y ; X [form="base"]; Y [form="on"]}
	commands { X.upos="VERB"; del_edge e; add_edge X -[comp:obl@fixed]-> Y }
}

rule closeTo {
	pattern { e : X -[unk@fixed|comp:pred@fixed|comp:obl@fixed]-> Y; X [form="close"]; Y [form="to"]}
	commands { del_edge e; add_edge X -[mod@fixed]-> Y}
}

rule unkFixed {
	pattern { e : X -[unk@fixed]-> Y}
	commands { del_edge e; add_edge X -[comp:obj@fixed]-> Y}
}

rule allPOSDet {
	pattern { X[form="all"] }
	without { X.upos=DET }
	commands { X.upos=DET }
}

rule mustAUX {
	pattern { X[form="must"] }
	without { X.upos=AUX }
	commands { X.upos=AUX }
}

rule mustTo {
	pattern { e : X -[comp:obl@x]-> Y; X [form="must"]; Y [form="to"]}
	without { X.upos=VERB }
	commands { X.upos=VERB }
}

rule modNum {
	pattern { e : X -> Y; X [upos=NOUN]; Y [upos=NUM]; X << Y }
	without { X -[flat|mod:num]-> Y }
	commands { del_edge e; add_edge X -[mod:num]-> Y }
}

rule detNum {
	pattern { e : X -> Y; X [upos=NOUN]; Y [upos=NUM]; X >> Y }
	without { X -[det:num]-> Y }
	commands { del_edge e; add_edge X -[det:num]-> Y }
}

rule allModRelation {
	pattern { e: GOV -> DEP ; GOV[upos=NOUN]; DEP [form="all"] ; DEP <<  GOV }
	without { GOV -[mod]-> DEP }
	commands { del_edge e; add_edge GOV -[mod]-> DEP }
}

rule ccFix {
	pattern { e: GOV -[root|root@scrap]-> DEP1; f: DEP1 -[cc]-> DEP2 }
	commands { del_edge f; add_edge DEP1 -[discourse]-> DEP2 }
}

rule fixedIdiomDependents {
	pattern { e1: N -> M ; N[PhraseType=Idiom]; e2: M -[1=X]-> T; M[InIdiom=Yes] }
	without { T [InIdiom=Yes] }
	commands { e1.2=U;
		del_edge e1;
		add_edge new_e: N -> T;
		new_e.label = e2.label;
	}
}

rule fixedIdiomDependents3 {
	pattern { X -> Y ; X[PhraseType=Idiom]; e: Y -[comp:obj]-> Z; Y[InIdiom=Yes] }
	without { Z [InIdiom=Yes] }
	commands {
		del_edge e;
		add_edge X -[comp:obj]-> Z
	}
}

rule fixedIdiomDependents4 {
	pattern {  A -> B; B -> C; e: C -[comp:obj]-> D; A[PhraseType=Idiom]; B[InIdiom=Yes]; C[InIdiom=Yes]}
	without { D [InIdiom=Yes] }
	commands {
		del_edge e;
		add_edge A -[comp:obj]-> D
	}
}

rule tellSey {
	pattern { e1 : N1 -[comp:obj]->N2   ; e2 : N1 -[comp:obl]-> N3 ; N2 << N3 ; N3 [form=sey] }
	commands {
		del_edge e1;
		add_edge N1 -[comp:obl]-> N2;
		del_edge e2;
		add_edge N1 -[comp:obj]-> N3
	}
}

rule conjCompound {
	pattern { e: GOV -[conj:coord|compound:svc]-> DEP ; GOV [upos=VERB, lemma=come|go]; DEP [upos=VERB] }
	without {DEP -[cc]-> CONJ }
	without {DEP -[punct]-> P ; P [form="|c"] }
	commands {
		del_edge e;
		add_edge GOV -[comp:obj@x]-> DEP
	}
}

rule doubleCompObj {
	pattern { e1: GOV -[comp:obj]-> DEP1 ; e2: GOV -[comp:obj]-> DEP2 ; GOV [upos=VERB] ; DEP1 << DEP2 }
	commands {
		del_edge e1;
		add_edge GOV -[comp:obl]-> DEP1
	}
}

rule takeObl {
	pattern { e: N1 -[compound:svc]-> N2 ; N2 [lemma=take] ; N2 -> N3 ; N3 [upos=VERB] }
	commands {
		del_edge e;
		add_edge N1 -[comp:obl@x]-> N2
	}
}

rule oRacine {
pattern { X -[root]-> Y; e: Z -> O; O [form="o"]; PUNCT [form="//"|"!//"|"?//"]; O < PUNCT }
without { PUNCT2 [form="//"|"!//"|"?//"|"]"]; PUNCT < PUNCT2; PUNCT3 [form="["]; Y -> O }
	commands {
		del_edge e;
		add_edge Y -[mod:emph]-> O
	}
}

rule noToAdj {
  pattern {
    NO [lemma=no, upos=PART];
		G [upos=VERB|AUX|ADJ];
    e: G -[mod]-> NO;
  }
  commands {
    del_edge e;
    shift_in G ==> NO;
    shift_out G =[punct|subj|mod:perif|mod:emph|dislocated|discourse|vocative|cc|conj:coord|conj:dicto|parataxis:conj]=> NO;
		add_edge NO -[comp:aux]-> G;
		NO.upos=AUX
  }
}

rule compXtoPred {
 pattern { e: GOV -[comp:obj@x|comp:obl@x]-> DEP }
 commands {
		del_edge e;
		add_edge GOV -[comp:pred]-> DEP
	}
}

rule goComeSVC {
 pattern { e: GOV -[comp:pred]-> DEP ; GOV [lemma=go|come] }
 commands {
		del_edge e;
		add_edge GOV -[compound:svc]-> DEP
	}
}

rule goComeSVCundo {
 pattern { e: GOV -[compound:svc]-> DEP ; GOV [lemma=go|come]; DEP [lemma<>come|go|comot] }
 commands {
		del_edge e;
		add_edge GOV -[comp:pred]-> DEP
	}
}

rule demDen {
 pattern { ITEM [lemma=dem]; ITEM [upos=ADV] }
 commands {
		ITEM.lemma=den
	}
}

rule herADJ {
 pattern { ITEM [form=her]; ITEM [upos=ADJ] }
 commands {
		ITEM.upos=PRON
	}
}

rule herPronType {
	pattern { N [upos<>ADJ, form=her]; H -[mod:poss]-> N }
	without { N [PronType=PRS] }
 	commands {
		N.PronType=PRS
	}
}

rule soDatRule {
	pattern { N1 [lemma="so"]; N2 [lemma="dat", upos=PRON]; N1 < N2 }
 	commands {
		N2.upos=SCONJ
	}
}

rule modMake {
	pattern { e:GOV -[mod]-> DEP ; DEP [lemma=make, upos=AUX] ; GOV [upos=VERB]; e2: DEP -[comp:aux]-> DEP2 }
 	commands {
	del_edge e;
	add_edge GOV -[mod$purp]-> DEP;
	del_edge e2;
	add_edge DEP -[comp:obj]-> DEP2;
	DEP.upos=SCONJ;
	DEP.Gloss=that;
	DEP.lemma=make;
	del_feat DEP.Mood
	}
}

rule modTo {
	pattern { e:GOV -[mod]-> DEP ; DEP [lemma=to] ; GOV [upos=VERB] ; DEP -> V ; V [upos=VERB|AUX] }
	commands {
	del_edge e;
	add_edge GOV -[mod$purp]-> DEP
	}
}

rule useTakeCarry {
	pattern { N1 [upos=VERB, lemma=use|take|carry] ; N2 [lemma=take] ; N3 [] ; e2: N2 -[compound:svc]->N3 ; e1: N1 -[comp:pred]-> N2 }
	commands {
	del_edge e1;
	add_edge N1 -[mod$purp]-> N2;
	del_edge e2;
	add_edge N2 -[comp:obj]-> N3;
	N2.upos=SCONJ;
	N2.Gloss=to
	}
}

rule desireWantTryStruggle {
	pattern { e:GOV -[comp:pred]-> DEP ; GOV [lemma="want"|"try"|"struggle"] }
	commands {
	del_edge e;
	add_edge GOV -[comp:pred$desire]-> DEP
	}
}

rule ifMod {
	pattern {e: GOV -[mod]-> DEP; DEP [lemma=if] }
	commands {
	del_edge e;
	add_edge GOV -[mod$cond]-> DEP
	}
}

rule ifModCond {
	pattern {e: GOV -[mod:periph]-> DEP; DEP [lemma=if] }
	commands {
	del_edge e;
	add_edge GOV -[mod:periph$cond]-> DEP
	}
}

rule tempoWhenMod {
	pattern { N2 [lemma="when"]; N3 [upos=VERB|AUX|ADJ] ; e: N1 -[mod]-> N2 ; N2 -[comp:obj]-> N3}
	commands {
	del_edge e;
	add_edge N1 -[mod$tempo]-> N2
	}
}

rule tempoWhenModPeriph {
	pattern { N2 [lemma="when"]; N3 [upos=VERB|AUX|ADJ] ; e: N1 -[mod:periph]-> N2 ; N2 -[comp:obj]-> N3}
	commands {
	del_edge e;
	add_edge N1 -[mod:periph$tempo]-> N2
	}
}

rule tempoAsMod {
	pattern { N2 [lemma="as", upos=ADP]; N3 [upos=AUX|VERB] ; e: N1 -[mod]-> N2 ; N2 -[comp:obj]-> N3}
	commands {
	del_edge e;
	add_edge N1 -[mod@tempo]-> N2
	}
}

rule tempoAsModPeriph {
	pattern { N2 [lemma="as", upos=ADP]; N3 [upos=AUX|VERB] ; e: N1 -[mod:periph]-> N2 ; N2 -[comp:obj]-> N3}
	commands {
	del_edge e;
	add_edge N1 -[mod:periph@tempo]-> N2
	}
}

rule tempBmod {
	pattern { N2 [lemma="before"]; N3 [upos=VERB|AUX|ADJ] ; e: N1 -[mod]->N2 ; N2 -[comp:obj]-> N3}
	commands {
	del_edge e;
	add_edge N1 -[mod$tempb]-> N2
	}
}

rule tempBmodPeriph {
	pattern { N2 [lemma="before"]; N3 [upos=VERB|AUX|ADJ] ; e: N1 -[mod:periph]->N2 ; N2 -[comp:obj]-> N3}
	commands {
	del_edge e;
	add_edge N1 -[mod:periph$tempb]-> N2
	}
}

rule tempAmod {
	pattern { N2 [lemma="after"]; N3 [upos=VERB|AUX] ; e: N1 -[mod]->N2 ; N2 -[comp:obj]-> N3}
	commands {
	del_edge e;
	add_edge N1 -[mod$tempa]-> N2
	}
}

rule tempAmodPeriph {
	pattern { N2 [lemma="after"]; N3 [upos=VERB|AUX] ; e: N1 -[mod:periph]->N2 ; N2 -[comp:obj]-> N3}
	commands {
	del_edge e;
	add_edge N1 -[mod:periph$tempa]-> N2
	}
}

rule goComePurp {
	pattern { e: N1 -[mod|comp:pred]-> N2 ; N1 [lemma=go|come, upos=VERB] ; N2 [upos=VERB|AUX]}
	commands {
	del_edge e;
	add_edge N1 -[comp:pred$purp]-> N2
	}

}


rule causativePred {
	pattern {N1 [lemma=make, upos=VERB] ; N2 [upos=NOUN|PRON] ;
	N3 [upos=VERB|AUX] ;
	N1 -> N2 ; e: N1 -[comp:pred]-> N3 }
	commands {
	del_edge e;
	add_edge N1 -[comp:pred$caus]-> N3
	}
}

rule goComeObl {
	pattern { e: GOV -[comp:obj]-> DEP ; GOV << DEP;
	GOV [lemma=go|come , upos=VERB];
	DEP [upos=NOUN|ADP] }
	commands {
	del_edge e;
	add_edge GOV -[comp:obl]-> DEP
	}
}

rule becauseModReason {
	pattern { e: N1 -[mod]-> N2 ;
	N1 [upos=VERB] ; N2 [lemma=because] }
	commands {
	del_edge e;
	add_edge N1 -[mod$reason]-> N2
	}
}

rule becauseModPeriphReason {
	pattern { e: N1 -[mod:periph]-> N2 ;
	N1 [upos=VERB] ; N2 [lemma=because] }
	commands {
	del_edge e;
	add_edge N1 -[mod:periph$reason]-> N2
	}
}

rule whileModTempo {
	pattern { N2 [lemma="while"]; N3 [upos=VERB|AUX|ADJ] ;
	e: N1 -[mod]-> N2 ; N2 -[comp:obj]-> N3}
	commands {
	del_edge e;
	add_edge N1 -[mod$tempo]-> N2
	}
}

rule whileModPeriphTempo {
	pattern { N2 [lemma="while"]; N3 [upos=VERB|AUX|ADJ] ;
	e: N1 -[mod:periph]-> N2 ; N2 -[comp:obj]-> N3}
	commands {
	del_edge e;
	add_edge N1 -[mod:periph$tempo]-> N2
	}
}

rule likeModManner {
	pattern { e: N1 -[mod]-> N2 ; N2 [lemma=like]; N1 [upos=VERB];
	N2 -[comp:obj]-> N3 ; N3 [upos=VERB|AUX]}
	commands {
	del_edge e;
	add_edge N1 -[mod$manner]-> N2
	}
}

rule soDatModPurp {
	pattern { N1 [form="so"]; N2 [form="dat"]; N1 < N2 ;
	e:N0 -[mod]-> N1 }
	commands {
	del_edge e;
	add_edge N0 -[mod$purp]-> N1
	}
 }

rule compPredSVCPurp {
	pattern {e: GOV -[comp:pred$purp]-> DEP }
	commands {
	del_edge e;
	add_edge GOV -[compound:svc$purp]-> DEP
	}
}

rule modPeriphPhaseToTempo {
	pattern {e: GOV -[mod:periph$phase]-> DEP }
	commands {
	del_edge e;
	add_edge GOV -[mod:periph$tempo]-> DEP
	}
}

rule parataxisDislocatedPhaseToTempo {
	pattern {e: GOV -[parataxis:dislocated$phase]-> DEP }
	commands {
	del_edge e;
	add_edge GOV -[parataxis:dislocated$tempo]-> DEP
	}
}

rule modAtTempoToDollar {
	pattern {e: GOV -[mod@tempo]-> DEP }
	commands {
	del_edge e;
	add_edge GOV -[mod$tempo]-> DEP
	}
}

rule modPeriphAtTempoToDollar {
	pattern {e: GOV -[mod:periph@tempo]-> DEP }
	commands {
	del_edge e;
	add_edge GOV -[mod:periph$tempo]-> DEP
	}
}

rule detToPron {
	pattern { N2 [form="all", upos=DET] ; e:N1 ->N2 ; N1 [upos=ADP|VERB|AUX] }
	commands {
	N2.upos=PRON
	}
}

rule modToDet {
	pattern { N1 [form="all"]; N2 [upos=DET]; N1 < N2 ; e:X-[mod]->N1 }
	commands {
	del_edge e;
	add_edge X -[det]-> N1
	}
}

rule compPredDesireToCompObjDesire {
	pattern { e: N1 -[comp:pred$desire]-> N2 }
	commands {
	del_edge e;
	add_edge N1 -[comp:obj$desire]-> N2 }
}

rule compPredCauseToCompObjCause {
	pattern { e: N1 -[comp:pred$cause]-> N2 }
	commands {
	del_edge e;
	add_edge N1 -[comp:obj$cause]-> N2 }
}

rule needToOblX {
	pattern { N1 [lemma="need"]; N2 [lemma="to"]; N1 < N2; e: N1 -[comp:pred]-> N2 }
	commands {
	del_edge e;
	add_edge N1 -[comp:obl@x]-> N2
	}
}

rule compObjDesireToObl {
	pattern { e: GOV -[comp:obj$desire]-> DEP ; GOV [lemma=want|try] ; DEP [upos=ADP]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obl$desire@x]-> DEP
	}
}

rule addXtoDesireWant {
	pattern { e: GOV -[comp:obj$desire]-> DEP ; GOV [lemma=want|try] ; DEP [upos=VERB|AUX] }
	commands {
	del_edge e;
	add_edge GOV -[comp:obj$desire@x]-> DEP
	}
}

rule addXtoDesireSuppose {
	pattern { e: GOV -[comp:obj$desire]-> DEP ; GOV [lemma=want|try|bother] ; DEP [lemma<>to]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obj$desire@x]-> DEP
	}
}

rule supposeToCompPredToOblX {
	pattern { e: GOV -[comp:pred]-> DEP ; GOV [lemma=suppose]; DEP [upos=ADP]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obl@x]-> DEP
	}
}

rule supposeToCompPredToObjX {
	pattern {e: GOV -[comp:pred]-> DEP ; GOV [lemma=suppose]; DEP [upos=VERB|AUX]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obj@x]-> DEP
	}
}

rule likeVerbAttitude {
	pattern {e: GOV -[comp:pred]-> DEP ; GOV [lemma=like]; DEP [upos=VERB]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obj$attitude@x]-> DEP
	}
}

rule likeDecideCompObl {
	pattern { e: GOV -[comp:pred]-> DEP ; GOV [lemma=decide|like] ; DEP [lemma=to]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obl$attitude@x]-> DEP
	}
}

rule startDeyPhase {
	pattern {e: GOV -[comp:pred]-> DEP ; GOV [lemma=start] ; DEP [upos=AUX]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obj$phase@x]-> DEP
	}
}

rule startBeginToPhase {
	pattern {e: GOV -[comp:pred]-> DEP ; GOV [lemma=start|begin] ; DEP [upos=ADP]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obl$phase@x]-> DEP
	}
}

rule startBeginVerbPhase {
	pattern {e: GOV -[comp:pred]-> DEP ; GOV [lemma=start|begin] ; DEP [upos=VERB|AUX]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obj$phase@x]-> DEP
	}
}

rule getToPhase {
	pattern {e: GOV -[comp:pred]-> DEP ; GOV [lemma=get] ; DEP [lemma=to]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obl$phase@x]-> DEP
	}
}

rule makeOblCauseX {
	pattern {e: GOV -[comp:pred$caus]-> DEP}
	commands {
	del_edge e;
	add_edge GOV -[comp:obl$cause@x]-> DEP
	}
}

rule makePredX {
	pattern {e: GOV -[comp:pred]-> DEP ; GOV [lemma=make] ; GOV -[comp:obj]-> X}
	commands {
	del_edge e;
	add_edge GOV -[comp:pred@x]-> DEP
	}
}

rule reasonPeriph {
	pattern {N2 [lemma="because"]; e:N1 -[mod:periph]->N2}
	commands {
	del_edge e;
	add_edge N1 -[mod:periph$reason]-> N2
	}
}

rule modCoreReason {
	pattern {N2 [lemma="because"]; e:N1 -[mod]->N2}
	commands {
	del_edge e;
	add_edge N1 -[mod$reason]-> N2
	}
}

rule compPredToOblPerception {
	pattern { e:GOV -[comp:pred]-> DEP ;
	DEP [upos=VERB|AUX] ;
	GOV [lemma=see|hear|smell|feel]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obl$percep@x]-> DEP
	}
}

rule sabiPredToAux {
	pattern {e: X -[comp:pred]-> Y ;
	Y [upos=VERB|AUX] ;
	X [lemma=know|sabi]}
	commands {
	del_edge e;
	add_edge X -[comp:obj$know@x]-> Y
	}
}

rule predToOblX {
	pattern { e: X -[comp:pred]-> Y ;
	X -[comp:obj]-> Z ;
	Y [upos=VERB|AUX|ADP] ;
	X [lemma<>na|dey|be|no|price|become|call|make]}
	commands {
	del_edge e;
	add_edge X -[comp:obl@x]-> Y
	}
}

rule predToObjX {
	pattern { e: X -[comp:pred]-> Y ;
	Y [upos=VERB|AUX] ;
	X [lemma<>na|dey|be|no|price|become|call|make]}
	without {X -[comp:obj]-> Z }
	commands {
	del_edge e;
	add_edge X -[comp:obj@x]-> Y
	}
}

rule udepToMod {
	pattern { e: GOV -[udep]-> DEP }
	commands {
	del_edge e;
	add_edge GOV -[mod]-> DEP
	}
}

rule useMustChoose {
	pattern { e: GOV -[comp:pred]-> DEP ; GOV [lemma=use|must|choose]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obl@x]-> DEP
	}
}

rule adjToNoun {
	pattern { N1 [upos=ADJ]; N2 [form="to"]; e:N1-[comp:obl]->N2 }
	without {N2 -> N3 ; N3 [upos=VERB]}
	commands {
	del_edge e;
	add_edge N1 -[mod]-> N2
	}
}

rule goObjToObl {
	pattern {e: GOV -[comp:obj]-> DEP ; GOV [lemma=go]}
	commands {
	del_edge e;
	add_edge GOV -[comp:obl]-> DEP
	}
}

rule mustToModal {
	pattern { e:GOV -[comp:pred]-> DEP ; GOV [lemma=must] ; DEP [lemma=to] }
	commands {
	del_edge e;
	add_edge GOV -[comp:obl$modal@x]-> DEP
	}
}

rule mustToModal2 {
	pattern { e:GOV -[comp:obl@x]-> DEP ; GOV [lemma=must] ; DEP [lemma=to] }
	commands {
	del_edge e;
	add_edge GOV -[comp:obl$modal@x]-> DEP
	}
}

rule letModal {
	pattern { e:GOV -[comp:obl@x]-> DEP ; GOV [lemma=let, upos=VERB] ;
	DEP [upos=VERB|AUX|ADP] }
	commands {
	del_edge e;
	add_edge GOV -[comp:obl$modal@x]-> DEP
	}
}

rule allowModal {
	pattern { e:GOV -[comp:obl@x]-> DEP ; GOV [lemma=allow, upos=VERB] ;
	DEP [upos=VERB|AUX|ADP] }
	commands {
	del_edge e;
	add_edge GOV -[comp:obl$modal@x]-> DEP
	}
}

rule makeSCONJ {
	pattern { e:N1 -[1=comp]-> N2 ;
	N1 [upos=VERB] ;
	N2 [lemma=make, upos=AUX] }
	commands {
	N2.upos=SCONJ;
	N2.Gloss=COMP;
	del_feat N2.Mood
	}
}

rule believeAttitude {
	pattern { e:N1 -[comp:obj]-> N2 ;
	N1 [lemma=believe];
	N2 [upos=SCONJ]
	}
	commands {
	del_edge e;
	add_edge N1 -[comp:obj$attitude]-> N2
	}
}

rule thinkSeyAttitude {
	pattern { e:N1 -[comp:obj]-> N2 ;
	N1 [lemma=think|tink];
	N2 [lemma=sey]
	}
	commands {
	del_edge e;
	add_edge N1 -[comp:obj$attitude]-> N2
	}
}

rule patataxisObjUtter {
	pattern { e:N1 -[parataxis:obj]-> N2 ;
	N1 [lemma=say|tell];
	N2 [upos=VERB|AUX|PART|ADJ]
	}
	commands {
	del_edge e;
	add_edge N1 -[parataxis:obj$utter]-> N2
	}
}

rule tellSeyUtter {
	pattern { e:N1 -[comp:obj]-> N2 ;
	N1 [lemma=tell] ;
	N2 [lemma=sey]
	}
	commands {
	del_edge e;
	add_edge N1 -[comp:obj$utter]-> N2
	}
}

rule sayZero {
	pattern { e:N1 -[comp:obj]-> N2 ;
	N1 [lemma=say];
	N2 [upos=VERB|AUX|PART|ADJ]
	}
	commands {
	del_edge e;
	add_edge N1 -[parataxis:obj$utter]-> N2
	}
}

rule makeCompObj {
	pattern { e: GOV -[comp:aux]-> DEP; GOV [upos <> AUX] }
	commands {
	del_edge e;
	add_edge GOV -[comp:obj]-> DEP
	}
}

rule noPartToAux {
	pattern { GOV -[subj]-> DEP; GOV[upos <> VERB|AUX, lemma=no] }
	without { GOV.ExtPos=VERB }
	without { GOV.ExtPos=AUX }
	commands {
	GOV.upos=AUX
	}
}

rule parataxisUtter {
	pattern { e:N -[parataxis:obj]-> M ; M [lemma=make, upos=AUX] ; N [upos<>undefined, lemma<>sey|say]; e2: M -[comp:aux]-> V }
	commands {
	del_edge e;
	add_edge N-[parataxis:obj$utter]-> M;
	M.upos=SCONJ;
	M.Gloss=COMP;
	del_feat M.Mood;
	del_edge e2;
	add_edge M -[comp:obj]-> V
	}
}

rule parataxisDislocatedCondToMod {
	pattern { e: M -[parataxis:dislocated$cond]-> N}
	commands {
	del_edge e;
	add_edge M -[parataxis:mod$cond]-> N
	}
}

rule modCondPeriph {
	pattern { e:GOV -[mod$cond]-> DEP ; GOV >> DEP}
	commands {
	del_edge e;
	add_edge GOV -[mod:periph$cond]-> DEP
	}
}

rule pronTypePrs {
	pattern { N [PronType=PRS] }
	commands {
	N.PronType=Prs
	}
}

rule aspFutToProsp {
	pattern { N [Aspect=Fut] }
	commands {
	N.Aspect=Prosp
	}
}

rule datPronType {
	pattern { N [form=dat]; N [PronType] }
	commands {
	del_feat N.PronType
	}
}


rule whenAdv {
	pattern { DEP [form="when"]; GOV -> DEP }
	without { DEP [upos=ADV] }
	commands {
	DEP.upos=ADV;
	}
}

rule whenNoun {
	pattern { DEP [form="when"]; GOV -> DEP; GOV [upos=AUX|VERB]; DEP [PronType] }
	without { DEP [upos=ADJ] }
	commands {
	DEP.upos=ADV;
	del_feat DEP.PronType
	}
}

rule testingTry {
	pattern { WORD [form="when"] }
	commands {
	del_node WORD
	}
}



strat main {
	Seq (
	Onf (aspFutToProsp),
	Onf (whenNoun)
)}
